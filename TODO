deal with namespace collapsing and finalize keyword properties

finalize syntax and refactor the standard
	-perhaps change operators to have names in declarations of user defined types (dereference, equality, assignment, et cetera)
		-assignment	=	unary
		-equality	==	binary
		-address_of	&	unary
		-dereference	*	unary
		-subscript	[]	unary
		-addition	+	binary
		-negation	-	unary
		-subtraction	-	binary
		-multiplication	*	binary
		-division	/	binary
		-inversion	/	unary
		-modulo		%	binary
		-exponentiation	^	binary
		-shift_left	<<	binary
		-shift_right	>>	binary
		-rol		<<<	binary
		-ror		>>>	binary
		-bitwise_or	|	binary
		-bitwise_and	&	binary
		-bitwise_xor	^	binary
		-bitwise_not	!	unary
		-less_than	<	binary
		-greater_than	>	binary
		-or		\/	binary
		-and		/\	binary
		-shortcut_or	||	binary
		-shortcut_and	&&	binary
		-negation	~	unary
		-implication	->	binary
		-xor		><	binary
		-biconditional	<->	binary
		-ternary_cmp	<=>	binary
		-dot		.	binary
		-come up with names for the odd ones
	-fixed ambiguity with default size abstraction
		-before
			-abstract:	"natural	n;"
			-default:	"natural	n;"
			-concrete:	"natural[B]	n;"
		-after
			-abstract:	"natural	n;"
			-default:	"natural[]	n;"
			-concrete:	"natural[B]	n;"
	-fix size{} ambiguity from swap to hyperexpressions
		-size{ value } for size abstraction of the value
		-SIZE{ value } for byte size of the type of the value

determine whether these syntaxes are okay:
	-//(this.obj = o.obj).obj_count++;
		-assignment of o.obj to this.obj then increment of obj_count of the returned this.obj
		-this syntax is okay since it's necessary for chaining member procedure calls like with the stream type from the standard library
	-//this.(x = y);
		-assignment of this.y to this.x
		-the member (maybe find a better name) operator would essentially act as a context passer
		-might be useful for certain tasks but might not be readily understandable

finish r_array and the rest of the collections

decide whether range can be a struct





set down the declarations for print and other basic things

make the formatting procedures for the basic types

parallelism utilities
	-essentially done now since a model of multiprocessing execution is added into the language

networking utilities
	-probably last to be done

update syntax in library and remove demos et cetera from the library
	-also update demos
	-finished updating syntax in the standard library

add dispatch keyword (only use gloabal thread pool) and versions that block and also run in the calling thread
	-task assignment
		-version with both "fills from the bottom," and version that runs in the calling thread but doesn't block "fills from the top"
		-calling thread takes off the task queue
		-maybe a hybrid version

maybe parallel keyword can have different uses on a block vs a declaration vs a hyperexpression

compiler option for a file that defines natural language aliases and a file that defines global project aliases
	-natural language aliases seem impractical at this point





abstract loops
	-the variable of abstract type that is within gets placed at the same location in memory (top of the stack) each time through the loop

one variable of abstract type is allowed to be allocated on the top of the stack in a procedure at a time
	-abstract loops are a use of this
	-if multiple are needed, an arena can be used as the one variable that can then allocate to the rest
	-should, in conjuction with great types like array and vector, allow use of variables/types without needing to specify pointers as often
