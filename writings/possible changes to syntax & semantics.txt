Constructors
	-either
		V-"failure" property (returns that type optionally)
			-two possibilities:
				-optional of the type
					-octor
						-need to see if there's a better letter to prepend
				-pointer to the type
					-"fctor"
						-f prepended to the ctor
						-is most of the word factory, as well
		X-allow adding any type on (returns a type that composes that type)
		X-allowing it to handle any natural transformations (maybe not necessary)



Functor operations to add to Y:
	F# name		Type						Y equivalent
	map		(A -> B) -> (M[A] -> M[B])			?

	apply		M[A -> B] -> (M[A] -> M[B])			?

	return		A -> M[A]					constructors

	bind		(A -> M[B]) -> (M[A] -> M[B])			?

	lift2		((A, B) -> C) -> ((M[A], M[B]) -> M[C])		?

Note:		map f x = bind return f x
AKA:		map f x = flatMap pure f x



Splaying & Multicomposability:
	-maybe allow f(a, b) to be expressed as f(c) where c is of type tuple of A and B
		-(this would go with the inclusion of multicomposability that I've been contemplating)
	-example of splaying:
		f: (A,B,C) -> X
		d: (A,B)
		e: (B,C)
		f(a,b,c) == f(d,c) == f(a,e)
	-example of multicomposability:
		pair: (dt, dt) sdt
		{
			dt#0 l;
			dt#1 r;
		}







Data Type Optimization:
	-allow for optimizing away member variables of a type
		-to allow for allocators in a type without taking space
		-add constant modifier to member variables



Compilation Options:
	-Optimization Levels:
		-None
		-Constants
		-Data Type and Inlining
	-constant boole DEBUGGING



Procedure Mutability:
	-now:
		-default
		-system
		-static
	-add modifiers to help with globals



Because of the focus on abstraction and saying what you mean, abstract scoped procedures don't only "template" in the types of the parameters.
	-They can be called at runtime with the simple compiler transform of parameters changing into immutable pointers to those parameters.
	-Also, this makes the implicit "this" parameter of types from an immutable pointer to the type into just being of the type it's in.



make it easier to use member procedures as arguments to procedures
	-perhaps allow ctor, dtor, et cetera to be used as such:	`somelist.map(dtor);`
	-find some syntax to reference them that's easier than wrapping in another procedure
		-perchance, `l_list:map` so `list_of_lists.map(list:empty);`
	-maybe some hyperexpressions can also be used as procedures with the obvious, trivial implementations:	`ptr_list.map(free);`



switch & choice statements
	-If a statement doesn't have a default case, err if not all cases are checked; otherwise, note how many cases the default case accounts for.
		-instead of specifying the number of unchecked cases in the default case of a switch or choice statement
		-allows for easier use of them as an equality check with types that have an arbitrary number of states
	-maybe use "else" instead of "default"



have constant(dt) and immutable(dt) make the whole type constant or immutable even through a root reference type
	-instead of having constant and immutable properties on variables
	-is more in line with how to use them with procedure types, both externally and internally
		-externally (the usual state):	constant(dt<<dt)
		-internally (also useful):		(constant(dt)<<natural)
	-has to start at a leaf type of the type
		-since the leaves are the only place a type could be reified into a reference type
		-example: dt array[2] pointer array[5]
			-without constant flooding
				dt array[2] constant pointer array[5]
				constant dt array[2] pointer array[5]
			-with new form
				-grammatical
					constant(dt array[2]) pointer array[5]
						-technically only needs to encompass the dt since array isn't a reference type
					constant(dt array[2] pointer array[5])
						-now how to make a type completely constant
				-err
					dt array[2] constant(pointer array[5])
		-multicomposition example: (dt, dt) pair pointer
			(constant(dt), dt) pair pointer
			(dt, constant(dt)) pair pointer
			constant(dt, dt) pair pointer
			constant((dt, dt) pair pointer)



just use a defined size abstraction to coalesce onto the pointer
	-instead of making new syntax
	-is more like older, terser syntax
	-allows for 'slicing' of many levels at once
	-example:	sort(natural[B] array[n] become arr);
	-also works with the become property



maybe use '#' syntax for just derived types
	-instead of resolving both derived types and SA parameters
	-maybe then allow the SA vector to have zero length to deal with all cases
		-example:	associative operator group#0 binary_+(group[n] a, group#0[m] b);



thinking about it, types that have the constant property have an odd relation to inheritance
	-their supertype should be `constant dt`, not `dt`
		-of course, because such types are like they always appear with `constant` before them
			-`stream` is as if it was written `constant stream`



